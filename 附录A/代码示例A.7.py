


"""
代码示例 A.7 :
    Python的元类（个人笔记，仅供参考）
"""

# https://dboyliao.medium.com/%E6%B7%BA%E8%AB%87-python-metaclass-dfacf24d6dd5

from types import MethodWrapperType
from typing import NewType


print("========== Inherited docstrings aren't particularly informative  ==========")

# Inherited docstrings aren't particularly informative:

class A(object):

    def test_function(self,):
        """ Do some stuff for class A. """
        pass

class B(A):
    pass

print(A().test_function.__doc__)  # > Do some stuff for class A. 
print(B().test_function.__doc__)  # > Do some stuff for class A. 

# More specifically...
# The mose testing framework will print out the docstrings of test methods as it runs them.

#   Unfortunately, if you have a test suite class that inherits from another class, you won't be able 
# to tell when it's running methods from parents class v.s. the subclass.

print("\n========== The simple Solution  ==========")

class A(object):

    def test_function(self,):
        """ Do some stuff for class A. """
        pass

class B(A):
    def test_function(self):
        """ Do some stuff for class B. """
        return super().test_function()

print(A().test_function.__doc__)
print(B().test_function.__doc__)

# But that's a lot of work if you have many subclasses and/or many methods.

print("\n========== A Better Solution?  ==========")

# Can we simply edit the docstrings in the __init__ of the superclass?
class A(object):
    def __init__(self):
        old_doc = self.my_func.__doc__
        cls_name = type(self).__name__
        self.my_func.__doc__ = "%s: %s".format(cls_name, old_doc)

    def my_func(self):
        "Do some stuff."

class B(A):
    pass

# Unfortunately, method docstrings aren't writable:
try:
    print(A().test_function.__doc__)
    print(B().test_function.__doc__)
except AttributeError:
    print(" attribute '__doc__' of 'method' objects is not writable")

# Note: Function docstrings, in general, are writable 
#     ----  it's just method docstrings that aren't
#   So, is there any way to change the function's docstrings before it
#   it becomes a method?

# Taking a step back: what is a class?
#   A class is a special kind of object which creates new objects called instances.
#   A class is kind of like a form (e.g., tax form 1040)
#   An instance is kind of like your specific copy of the form


print("\n========== type will tell us the class of an instance:  ==========")

class A(object):
    def my_func(self,):
        "Do some stuff."
        pass
a_inst = A()
print("Instance 'a_inst' has type: ", type(a_inst).__name__)

# Remenber, everything in Python is an object!
# So, classes have types, too:
print("Class 'A' has type:", type(A).__name__)

# In other words, classes are generated by a special type called type
# (Yes, the terminology is a bit confusing)


# A word on type
#   The type object actually does a few different things:
#  1. It denotes a type of object (the type of classes, specifically)
#  2. It tells you what type an object is;
#  3. It can create new classes

print("\n========== Creating a class on the fly:  ==========")
# This is the type of class declaration you're used to:
class A(object):
    def my_func(self):
        """Do some stuff."""

# But we can also use the type type to create new classes on demand:

def my_func(self,):
    """Do some stuff."""
    pass
A_name = "A"
A_parents = (object,)
A_methods = {"my_func": my_func}
A = type(A_name, A_parents, A_methods)

print("\n========== Modifying the docstring, take II:  ==========")

def make_class(name, parents, methods):
    """Create a new class and prefix its method's \
        docstrings to include the class name"""

    for f in methods:
        methods[f].__doc__ = "{}: {}".format(name, methods[f].__doc__)
    cls = type(name, parents, methods)
    return cls

A = make_class("A", (object, ), {"my_func": my_func})
print(A().my_func.__doc__)

B = make_class("B", (A, ), {"my_func": my_func})
print(B().my_func.__doc__)
# Oops, that wasn't what we wanted! What happened?
# What happened was that we modified the docstring of the same object (function) in the memory.

print(A.my_func is B.my_func)
print(my_func.__doc__)

print("\n========== Creating functions on the fly:  ==========")

##  Luckily, we can programmatically create functions using the function type, too!

def copy_function(f):
    """ Create a new function in memory is a duplicate of 'f'."""
    func_type = type(f)
    new_func = func_type(
        f.__code__,      # bytecode
        f.__globals__,   # global namespace
        f.__name__,      # function name
        f.__defaults__,  # default keyword argument values
        f.__closure__)   # closure variables 
    new_func.__doc__ = f.__doc__
    return new_func

def my_func(self,):
    """ Do some stuff."""
    pass
my_new_func = copy_function(my_func)
my_new_func.__doc__ = "modified: {}".format(my_func.__doc__)

print(my_func.__doc__)
print(my_new_func.__doc__)


print("\n========== Modifying the docstring, take III:  ==========")


def make_class(name, parents, methods):
    """Create a new class and prefix its method's \
        docstrings to include the class name"""

    for f in methods:
        # copy the function, overwrite the docstring, and replace the old method
        new_func = copy_function(methods[f])
        new_func.__doc__ = "{}:{}".format(name, methods[f].__doc__)
        methods[f] = new_func
    cls = type(name, parents, methods)
    return cls

# now it works!
A = make_class("A", (object, ), {"my_func": my_func})
B = make_class("B", (A,),  {"my_func": my_func})

print(A().my_func.__doc__)
print(B().my_func.__doc__)

# A metaclass is any callable that takes parameters for:
## 1. the class name
## 2. the class's bases (parent classes)
## 3. the class's attributes (methods and variables)

# The type type we were using before is just the default metaclass.

# the function make_class is technically a metaclass, too!
## 1. It takes three arguments for the class's name, bases, and attributes
## 2. It modifies the attributes by creating copies of the functions and editing their docstings.
## 3. It creates a new class using these modified attributes.
## 4. It returns the new class.

# However, Python creates classes in a slightly more complex way than we were creating classes
# We need to modify our make_class function to ignore other class attributes (e.g. non-functions):

def make_class(name, parents, attrs):
    """ Create a new class and prefix its method's \
        docstrings to include the class name """

    for a in attrs:
        # skip special methods and non-functions 
        if a.startswith("__") or not hasattr(attrs[a], "__call__"):
            continue

        # copy the function, overwrite the docstring, and replace the old method
        new_func = copy_function(attrs[a])
        new_func.__doc__ = "{}: {}".format(name, attrs[a].__doc__)
        attrs[a] = new_func

    cls = type(name, parents, attrs)
    return cls

# Now, all we need is a little special "syntactic sugar" in our class definition, and it works!

class A(object, metaclass=make_class):
    # __metaclass__ = make_class
    
    def my_func(self, ):
        """Do some stuff. """
        pass

print(A().my_func.__doc__)

# So, what exactly did we do?
##  (i.e., getting meta about metaclasses)
#   Metaclass intervene on class (not instance) creation.
# This gives us an opportunity to modify the class's methods before the class is actually created:
## 1. Copy each of the functions that will later become methods.
## 2. Change the docstrings of these new functions
## 3. Create the class using these new functions instead of the ones that were originally given.

print("\n========== A side note...  ==========")
# Subclasses still won't actually rewrite the docstring correctly:

class A(object, metaclass = make_class):
    def my_func(self):
        "Do some stuff."
        pass

class B(A):
    pass

print(A().my_func.__doc__)   # >> A: Do some stuff.
print(B().my_func.__doc__)

